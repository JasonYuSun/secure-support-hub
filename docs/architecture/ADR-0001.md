# ADR-0001: Stateless JWT Authentication over Server-Side Sessions

- **Date**: 2026-02-26
- **Status**: Accepted
- **Deciders**: Engineering Team
- **Technical Story**: Implement authentication for the Secure Support Hub MVP

---

## Context and Problem Statement

The Secure Support Hub requires a secure, scalable authentication mechanism for a React SPA frontend communicating with a Spring Boot REST API. We need to support three roles (`USER`, `TRIAGE`, `ADMIN`) with per-endpoint authorization controlled server-side.

The two primary options considered were:

1. **Stateless JWT tokens** — self-contained tokens signed with a secret; validated server-side on every request without database lookups.
2. **Server-side sessions** — session IDs stored in a database (e.g., Redis or PostgreSQL); server validates the ID on every request.

---

## Decision

We will use **stateless JWT access tokens** (signed with HMAC-SHA256) issued at login. Tokens carry the user's roles as claims and are validated by a `JwtAuthenticationFilter` in the Spring Security filter chain.

Token configuration:
- **Algorithm**: HS256 (symmetric HMAC-SHA256)
- **Expiry**: 24 hours (configurable via `JWT_EXPIRY_MS` env var)
- **Claims**: `sub` (username), `roles` (list), `iat`, `exp`
- **Transport**: `Authorization: Bearer <token>` header
- **Storage**: `localStorage` in the SPA (acceptable for MVP; consider `HttpOnly` cookies for production hardening)

---

## Rationale

| Criterion                      | JWT (stateless)              | Server-side sessions                               |
| ------------------------------ | ---------------------------- | -------------------------------------------------- |
| Horizontal scalability         | ✅ No shared state            | ❌ Requires sticky sessions or shared session store |
| DB round-trip per request      | ✅ None                       | ❌ Every request                                    |
| Token revocation               | ❌ Complex (blocklist needed) | ✅ Simple (delete session)                          |
| Implementation complexity      | ✅ Simple with jjwt library   | Moderate (Redis/pgSession setup)                   |
| Stateless API (REST principle) | ✅ Fully stateless            | ❌ Stateful                                         |

For the MVP, **scalability** and **implementation simplicity** outweigh the lack of instant revocation. The 24-hour expiry limits blast radius for compromised tokens.

---

## Consequences

### Positive
- API servers are fully stateless; any instance can validate any token.
- No additional infrastructure (Redis) required for MVP.
- Straightforward integration with Spring Security's `UsernamePasswordAuthenticationFilter` replacement.

### Negative / Mitigations
- **No instant revocation**: Mitigated by short expiry (24 h) and designing a token blocklist as a post-MVP enhancement.
- **Secret rotation**: Rotating `JWT_SECRET` invalidates all active tokens. Documented in the deployment runbook.
- **localStorage XSS risk**: Acceptable for MVP behind strict CSP headers. Post-MVP: migrate to `HttpOnly` cookie transport.

---

## Implementation References

- `apps/api/src/main/java/com/suncorp/securehub/security/JwtTokenProvider.java` — token issue + validate
- `apps/api/src/main/java/com/suncorp/securehub/security/JwtAuthenticationFilter.java` — Spring Security filter
- `apps/api/src/main/java/com/suncorp/securehub/config/SecurityConfig.java` — filter chain configuration
- `apps/web/src/auth/AuthContext.tsx` — client-side JWT storage + decode
